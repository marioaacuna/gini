function h = violinDistribution(data, varargin)
% violinDistributions generates a violin plot, which is a smoothed histogram.
%       It is particularly useful to compare two distributions side 
%       by side.
% 
% --- SYNTAX (type 'plotViolin ?' for a complete example)
% h = plotViolin (data, varargin)
% 
% --- INPUTS
% data [vector]: data points are arranged in a column vector.
% 
% --- OPTIONAL INPUTS
% Center [scalar]: center of histogram [0].
% f [scalar]: bandwidth of smoothing kernel [4].
% axis [string]: {'v','h'} Histogram orientation (vertical or horizontal).
% side [scalar]: {0,-1,+1} Draws violin plot on both sides (0), on
%       right/upper side (+1), or left/down side (-1). Thsi is useful to
%       plot two distributions side by side.
%
% This function accepts also additional arguments provided to the function
% 'fill', like 'FaceColor', 'EdgeColor', 'LineWidth' and so on.
% 
% --- OUTPUTS
% h [handle]: handle of surface plot generated by function 'fill'
% 
% 
% See also  fill
% 

p = inputParser();
addOptional(p, 'Center', 0);
addParameter(p, 'f', 4);
addParameter(p, 'Side', 0);
addParameter(p, 'Axis', 'v');
addParameter(p, 'FaceColor', [.7 .7 .7]);
addParameter(p, 'EdgeColor', 'none');
addParameter(p, 'LineWidth', 1);
addParameter(p, 'FaceAlpha', .4);
addParameter(p, 'NumPoints', 1000);
parse(p, varargin{:});
Center = p.Results.Center;
f = p.Results.f;
Side = p.Results.Side;
Axis = p.Results.Axis;
FaceColor = p.Results.FaceColor;
EdgeColor = p.Results.EdgeColor;
LineWidth = p.Results.LineWidth;
FaceAlpha = p.Results.FaceAlpha;
NumPoints = p.Results.NumPoints;

% Smooth ditribution
data = data(:); % Data is a column vector
[xHist,yHist] = ksdensity(data,'kernel','normal','width',f,'NumPoints',NumPoints);
xHist = xHist ./max(xHist) ./2; % Normalise in range [-.5 .5]

switch lower(Axis)
    case 'v', x=xHist; y=yHist; S=[-1, -1]; C=[Center, 0];
    case 'h', x=yHist; y=xHist; S=[+1, -1]; C=[0, Center];
end
x=x(:)'; y=y(:)'; % Make two row vectors

switch Side
    case  0
        h = fill([x * S(1) fliplr(x)] + C(1), [y * -S(2) fliplr(y)] + C(2), 0);
    case -1
        h = fill(x * S(1) + C(1), C(2) + y * -S(1), 0);
    case 1
        h = fill(x + C(1), y + C(2), 0);
end

set(h, 'FaceColor',FaceColor, 'EdgeColor',EdgeColor, 'LineWidth',LineWidth, 'FaceAlpha',FaceAlpha)

if nargout==0, clear h, end
